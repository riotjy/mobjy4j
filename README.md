# **mobjy** for Java

**mobjy** for Java is a data model implementation utility providing automated
data processing code generation.

![Image: ./res/readme.png](https://gitlab.com/riotjy/mobjy4j/-/raw/master/res/readme.png)
*(Click on the image for hi-res viewing)*

**mobjy** simplifies the production of ample JSON-data manipulation code (Java, C++)
using a fairly easy to write YAML specification.
*(see full YAML example and generated code below)*

**mobjy** processes the data model specification in YAML and outputs Java and C++ 
embeddable code comprised of:
- the data model entities hierarchy as OOP classes
- a serializer utility class to convert in-process data objects to JSON 
- a deserializer utility class to convert from JSON to in-process data objects

The idea for **mobjy** came from hardships encountered by the initial author in past
projects where data objects and handlers were written in multiple languages,
and each data model change required the programmers to revise and modify code for
multiple data objects and converters in multiple projects and languages.

**mobjy** supports object oriented hierarchies (inheritance) making the conversion
between in process data objects and JSON data possible while
ensuring the proper creation of the intended in process class instances.
It also supports the specification of class and field level **_Java annotations_**,
useful for ORM purposes (e.g. Hibernate).

In its current verison **mobjy** is using the *gson* and *nlohmann/json* libraries
for parsing and extracting JSON data.
It avoids using the automatic object creation provided by these libraries in order
to support library interchangeability in the future (e.g. *jackson*, *jsoncpp*).

**mobjy** is intended to be extended to support other languages and also multiple
approaches for the same language.
For example in addition the the C++11 compatible code currently generated by the tool,
future C++ code may include optimizations for C++14/17/20.

Next development steps:
- support for C#
- geospatial data type(s)
- temporal data type(s)

These depend on available time and resources to continue development.

## ABOUT:

**riotjy** and its projects was initiated in Jan 2020 and is currently maintained by **Alex Savulov**
*(currently the sole contributor, hopefully more will join ;-)*.

**mobjy** is the first part of the **riotjy** open source suite, an initiative,
to produce tools, utilities, service code for IoT with emphasis on multilanguage,
cross-platform development. 
**"mobjy"** loosely stands for **m**odelling **ob**jects **j**son **y**aml.
**"riotjy"** loosely stands for **r**apid (or **r**esources for)  **IoT** **j**son **y**aml.

KEYWORDS: JSON inheritance support, JSON data model, JSON data modeling,
JSON object hierarchy, JSON serialize deserialize,
Oject Oriented JSON, JSON model automation

IMPORTANT NOTE: The project is in an early stage. Please be kind to it! ;-)

## TO CONTRIBUTORS:

You are welcome to contribute if you're interested and agree to ApL2.0.

Contact **Alex Savulov** for access. 

Message to [ r i o t j y ] [ p r o t o n m a i l ] [ c o m ] (fill in missing).


## USING mobjy4j

BUILD INSTRUCTIONS:

Gradle: run gradlew.* script, specify desired build task.

Eclipse: install buildship extension for Gradle support, import as existing
gradle project, build project.

RUNNING INSTRUCTIONS:

Run class "Mobjy" with parameter **-i** set to the full/relative path to input
YAML file and **-o** parameter to the output directory/folder.
**mobjy** will generate a bunch of java and cpp files in there.

For convenience, the Gradle task **buildFatJar** in the launch group *buildfatjar*
will build a fat jar incorporating all needed libraries: *./build/libs/Mobjy-all.jar*

Also for convenience you can find a copy of the fat jar under *./fatjar/Mobjy-all.jar* built for Java 11,
but it is recommended, you build it yourself.

To launch *cd* to the project root and use the command:
```
java -cp ./build/libs/Mobjy-all.jar dev.riotjy.mobjy.Mobjy -i ./examples/example.yaml -o /home/riotjy/mobjy/out
```
or
```
java -cp ./fatjar/Mobjy-all.jar dev.riotjy.mobjy.Mobjy -i ./examples/example.yaml -o /home/riotjy/mobjy/out
```
if you want to use the prebuilt fat jar.

In order to use the output code files, currently the *gson* library for java
and the *nlohmann/json (json.hpp)* library for C++ are needed.

The serializer and deserializer provide the methods/functions serialize(...)
and deserialize(...) for each supported language.

Passing a generated class instance to the serializer will result in a JSON string.
Passing a compatible JSON string to the deserializer will result in an object of
the type passed to the serializer.
It is recommended to manufacture the JSON data using the serializer instead of
other methods to ensure compatibility and error free execution.
For debugging purposes, a generated JSON data string can be then used as a template.

## WHAT CAN IT DO:

It can turn the following YAML class model definition (./examples/example.yaml)
into the follwing Java and C++ code. (scroll down)

## YAML input
```YAML
%YAML 1.1
---
# YAML defined model example
project: demoProject

java:                    # project level language dependent setting
  package: dev.riotjy.demoProject
  
cpp:
  namespace: demoproject
  
csharp:                  # c# support not implemented yet
  namespace: DemoProject

#NOTES:
#keywords: 
#  class, extends, type, collection, references, meta
#  bool, int, string, float, double, 
#  version, compatver, project
#  java, cpp, csharp, path, resource, references
#
#structure:
#  Except the first level elements that are keywords (see above)
#  All other first level elements are classes (objects) definitions
#  which can contain fields
#  All second level elements are fields of classes (objects)
#  The YAML hierarchy of mappings gives the structure of the classes
#
#guidance:
#  The only restrictions on the syntax used in this model definition
#  file are imposed by the YAML 1.1 specification.
#  It is recommended to avoid using any language specific keywords 
#  as class or field names. There is currently no check for that,
#  the model developer is responsible for ensuring that.
#  The only structural restriction for the class model currently
#  is that cyclic inheritance is not allowed. If encountered,
#  the processing of the model will fail.

# classes definition example
BaseClass:                # creates class BaseClass with the following fields(members)
  intBase: int            # creates an int field (see below example for all primitives supported)

  objBase:                # creates an object of type RefClassOne
    type: RefClassOne
  objArrBase:             # creates an array list of objects of type RefClassTwo
    type: RefClassTwo
    collection: arrayList 
  objMapBase:             # creates a hash map <string, RefClassTwo>
    type: RefClassTwo
    collection: hashMap


DervClassOne:             # creates class DervClassOne extending BaseClass
  extends: BaseClass  
  intDervOne: int
  strDervOne: string
  objDervOne:
    type: RefClassOne
    collection: arrayList
  mapOneDervOne:
    type: RefClassTwo
    collection: hashMap


DervClassTwo:             # creates class DervClassOne extending DervClassTwo
  extends: DervClassOne
  intDervTwo: int
  strDervTwo: string
  objDervTwo:
    type: ExternalClassType
  mapDervTwo:
    type: ExternalClassType4Coll
    collection: hashMap


RefClassOne:              #creates class RefClassOne
  intRefOne: int
  strRefOne: string


RefClassTwo:              #creates class RefClassTwo
  intRefTwo: int
  strRefTwo: string


ExternalClassType:        # wraps an external class to be imported and used as type
   java:
      path: dev.riotjy.demo.extclass.ExtClassJ  # import directive
      class: ExtClassJ                          # actuall language dependent class name
   cpp:
      path: '"ext/ExtClassCpp.hpp"'             # include directive
      class: ExtClassCpp                        # actuall language dependent class name
   csharp:
      path: n1.n2.ExtClassCS                    # using directive
      class: ExtClassCS                         # actuall language dependent class name

ExternalClassType4Coll:    # wraps an external class to be imported and used as type
   java:
      path: dev.riotjy.demo.extclass.ExtClass4CollJ
      class: ExtClass4CollJ
   cpp:
      path: '"ext/ExtClass4CollCpp.hpp"'        # using single quotes to specify relative path
      class: ExtClass4CollCpp
   csharp:
      path: ns1.ns2
      class: ExtClass4CollCS


PrimitivesClass:
  boolOne: bool
  charOne: char
  byteOne: byte
  shortOne: short
  intOne: int
  longOne: long
  flOne: float
  dblOne: double
  strOne: string

  intTwo: int         # shorthand style for primitives
  intThree:           # detailed style for primitives (needed when using annotations, see below example)
    type: int
  intArrOne: int[]    # creates an array of integer primitives (shorthand notation)

  boolArrOne: bool[]  # creates an array of booleans (somewhat inefficient)
  strArrOne: string[] # creates an array list of strings
  flArr: float[]      # creates an array list of single precision float primitives
  dblArrOne: double[] # creates an array list of double precision float primitives

  dblArrTwo:          # detailed style for primitives (needed when using annotations, see below example)
    type: double
    collection: arrayList


AnnotatedClass:
  meta:                                          # class level meta data
    java:                                        # java annotations
      Entity:                                    # creates @Entity
      Table: '(name = "ANNOTATED_TABLE")'        # creates @Table(name="ANNOTATED_TABLE")
    csharp:                                      # c# attributes (not implemented yet)
      Attr1: 'attr text/content/value'           # creates [Attr1(attr text/content/value)]

  id:                                            # creates an annotated integer
    type: int
    meta:                                        # field level meta data
      java:                                      # java annotations
        Id: '()'                                 # creates @Id()
        GeneratedValue:                          # creates @GeneratedValuesomesetting
        Column: '(name = "id")'                  # creates @Column(name="id")
      csharp:                                    # c# attributes (not implemented yet)
        Attr2: 'attr text/content/value'         # creates [Attr2(attr text/content/value)]
        
  intArrExample:                                 # creates an annotated array of integer primitives
    type: int
    collection: arrayList
    meta:
      java:
        ManyToAny: '(metaColumn = @Column(name = "property_type"))'
        JoinColumn: |-                           # multiline annotation using |-
          (name="parent_id", insertable=false,
              updatable=false, nullable=false)   # using more spaces to indent the second line
        OrderColumn: '(name="order")'
```

## JAVA output: 

```Java
package dev.riotjy.demoProject;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Set;

public class BaseClass {

  protected Integer intBase;

  public Integer getIntBase() {
    return this.intBase;
  }

  public void setIntBase(Integer intBase) {
    this.intBase = intBase;
  }

  protected RefClassOne objBase;

  public RefClassOne getObjBase() {
    return this.objBase;
  }

  public void setObjBase(RefClassOne objBase) {
    this.objBase = objBase;
  }

  protected ArrayList<RefClassTwo> objArrBase = new ArrayList<>();

  public int sizeObjArrBase() {
    return this.objArrBase.size();
  }

  public RefClassTwo getObjArrBase(int index) {
    if (index >= objArrBase.size())
      return null;
    return this.objArrBase.get(index);
  }

  public RefClassTwo setObjArrBase(int index, RefClassTwo value) {
    if (index >= objArrBase.size())
      return null;
    return this.objArrBase.set(index, value);
  }

  public RefClassTwo removeObjArrBase(int index) {
    if (index >= objArrBase.size())
      return null;
    return this.objArrBase.remove(index);
  }

  public RefClassTwo popFrontObjArrBase() {
    if (0 == objArrBase.size())
      return null;
    return this.objArrBase.remove(0);
  }

  public void pushBackObjArrBase(RefClassTwo value) {
    this.objArrBase.add(value);
  }

  public Iterator iteratorObjArrBase() {
    return this.objArrBase.iterator();
  }

  protected HashMap<String, RefClassTwo> objMapBase = new HashMap<>();

  public int sizeOfObjMapBase() {
    return this.objMapBase.size();
  }

  public RefClassTwo getObjMapBase(String key) {
    return this.objMapBase.get(key);
  }

  public void putObjMapBase(String key, RefClassTwo value) {
    this.objMapBase.put(key, value);
  }

  public RefClassTwo removeObjMapBase(String key) {
    return this.objMapBase.remove(key);
  }

  public Set<String> keySetObjMapBase() {
    return this.objMapBase.keySet();
  }

}

********************************************************************************
package dev.riotjy.demoProject;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Set;

public class DervClassOne extends BaseClass {

  protected Integer intDervOne;

  public Integer getIntDervOne() {
    return this.intDervOne;
  }

  public void setIntDervOne(Integer intDervOne) {
    this.intDervOne = intDervOne;
  }

  protected String strDervOne;

  public String getStrDervOne() {
    return this.strDervOne;
  }

  public void setStrDervOne(String strDervOne) {
    this.strDervOne = strDervOne;
  }

  protected ArrayList<RefClassOne> objDervOne = new ArrayList<>();

  public int sizeObjDervOne() {
    return this.objDervOne.size();
  }

  public RefClassOne getObjDervOne(int index) {
    if (index >= objDervOne.size())
      return null;
    return this.objDervOne.get(index);
  }

  public RefClassOne setObjDervOne(int index, RefClassOne value) {
    if (index >= objDervOne.size())
      return null;
    return this.objDervOne.set(index, value);
  }

  public RefClassOne removeObjDervOne(int index) {
    if (index >= objDervOne.size())
      return null;
    return this.objDervOne.remove(index);
  }

  public RefClassOne popFrontObjDervOne() {
    if (0 == objDervOne.size())
      return null;
    return this.objDervOne.remove(0);
  }

  public void pushBackObjDervOne(RefClassOne value) {
    this.objDervOne.add(value);
  }

  public Iterator iteratorObjDervOne() {
    return this.objDervOne.iterator();
  }

  protected HashMap<String, RefClassTwo> mapOneDervOne = new HashMap<>();

  public int sizeOfMapOneDervOne() {
    return this.mapOneDervOne.size();
  }

  public RefClassTwo getMapOneDervOne(String key) {
    return this.mapOneDervOne.get(key);
  }

  public void putMapOneDervOne(String key, RefClassTwo value) {
    this.mapOneDervOne.put(key, value);
  }

  public RefClassTwo removeMapOneDervOne(String key) {
    return this.mapOneDervOne.remove(key);
  }

  public Set<String> keySetMapOneDervOne() {
    return this.mapOneDervOne.keySet();
  }

}

********************************************************************************
package dev.riotjy.demoProject;
import java.util.HashMap;
import java.util.Set;

public class DervClassTwo extends DervClassOne {

  protected Integer intDervTwo;

  public Integer getIntDervTwo() {
    return this.intDervTwo;
  }

  public void setIntDervTwo(Integer intDervTwo) {
    this.intDervTwo = intDervTwo;
  }

  protected String strDervTwo;

  public String getStrDervTwo() {
    return this.strDervTwo;
  }

  public void setStrDervTwo(String strDervTwo) {
    this.strDervTwo = strDervTwo;
  }

  protected ExternalClassType objDervTwo;

  public ExternalClassType getObjDervTwo() {
    return this.objDervTwo;
  }

  public void setObjDervTwo(ExternalClassType objDervTwo) {
    this.objDervTwo = objDervTwo;
  }

  protected HashMap<String, ExternalClassType4Coll> mapDervTwo = new HashMap<>();

  public int sizeOfMapDervTwo() {
    return this.mapDervTwo.size();
  }

  public ExternalClassType4Coll getMapDervTwo(String key) {
    return this.mapDervTwo.get(key);
  }

  public void putMapDervTwo(String key, ExternalClassType4Coll value) {
    this.mapDervTwo.put(key, value);
  }

  public ExternalClassType4Coll removeMapDervTwo(String key) {
    return this.mapDervTwo.remove(key);
  }

  public Set<String> keySetMapDervTwo() {
    return this.mapDervTwo.keySet();
  }

}

********************************************************************************
package dev.riotjy.demoProject;

public class RefClassOne {

  protected Integer intRefOne;

  public Integer getIntRefOne() {
    return this.intRefOne;
  }

  public void setIntRefOne(Integer intRefOne) {
    this.intRefOne = intRefOne;
  }

  protected String strRefOne;

  public String getStrRefOne() {
    return this.strRefOne;
  }

  public void setStrRefOne(String strRefOne) {
    this.strRefOne = strRefOne;
  }

}

********************************************************************************
package dev.riotjy.demoProject;

public class RefClassTwo {

  protected Integer intRefTwo;

  public Integer getIntRefTwo() {
    return this.intRefTwo;
  }

  public void setIntRefTwo(Integer intRefTwo) {
    this.intRefTwo = intRefTwo;
  }

  protected String strRefTwo;

  public String getStrRefTwo() {
    return this.strRefTwo;
  }

  public void setStrRefTwo(String strRefTwo) {
    this.strRefTwo = strRefTwo;
  }

}

********************************************************************************
package dev.riotjy.demoProject;

import dev.riotjy.demo.extclass.ExtClassJ;


public class ExternalClassType extends ExtClassJ {

}

********************************************************************************
package dev.riotjy.demoProject;

import dev.riotjy.demo.extclass.ExtClass4CollJ;


public class ExternalClassType4Coll extends ExtClass4CollJ {

}

********************************************************************************
package dev.riotjy.demoProject;
import java.util.ArrayList;
import java.util.Iterator;

public class PrimitivesClass {

  protected Boolean boolOne;

  public Boolean getBoolOne() {
    return this.boolOne;
  }

  public void setBoolOne(Boolean boolOne) {
    this.boolOne = boolOne;
  }

  protected Character charOne;

  public Character getCharOne() {
    return this.charOne;
  }

  public void setCharOne(Character charOne) {
    this.charOne = charOne;
  }

  protected Byte byteOne;

  public Byte getByteOne() {
    return this.byteOne;
  }

  public void setByteOne(Byte byteOne) {
    this.byteOne = byteOne;
  }

  protected Short shortOne;

  public Short getShortOne() {
    return this.shortOne;
  }

  public void setShortOne(Short shortOne) {
    this.shortOne = shortOne;
  }

  protected Integer intOne;

  public Integer getIntOne() {
    return this.intOne;
  }

  public void setIntOne(Integer intOne) {
    this.intOne = intOne;
  }

  protected Long longOne;

  public Long getLongOne() {
    return this.longOne;
  }

  public void setLongOne(Long longOne) {
    this.longOne = longOne;
  }

  protected Float flOne;

  public Float getFlOne() {
    return this.flOne;
  }

  public void setFlOne(Float flOne) {
    this.flOne = flOne;
  }

  protected Double dblOne;

  public Double getDblOne() {
    return this.dblOne;
  }

  public void setDblOne(Double dblOne) {
    this.dblOne = dblOne;
  }

  protected String strOne;

  public String getStrOne() {
    return this.strOne;
  }

  public void setStrOne(String strOne) {
    this.strOne = strOne;
  }

  protected Integer intTwo;

  public Integer getIntTwo() {
    return this.intTwo;
  }

  public void setIntTwo(Integer intTwo) {
    this.intTwo = intTwo;
  }

  protected Integer intThree;

  public Integer getIntThree() {
    return this.intThree;
  }

  public void setIntThree(Integer intThree) {
    this.intThree = intThree;
  }

  protected ArrayList<Integer> intArrOne = new ArrayList<>();

  public int sizeIntArrOne() {
    return this.intArrOne.size();
  }

  public Integer getIntArrOne(int index) {
    if (index >= intArrOne.size())
      return null;
    return this.intArrOne.get(index);
  }

  public Integer setIntArrOne(int index, Integer value) {
    if (index >= intArrOne.size())
      return null;
    return this.intArrOne.set(index, value);
  }

  public Integer removeIntArrOne(int index) {
    if (index >= intArrOne.size())
      return null;
    return this.intArrOne.remove(index);
  }

  public Integer popFrontIntArrOne() {
    if (0 == intArrOne.size())
      return null;
    return this.intArrOne.remove(0);
  }

  public void pushBackIntArrOne(Integer value) {
    this.intArrOne.add(value);
  }

  public Iterator iteratorIntArrOne() {
    return this.intArrOne.iterator();
  }

  protected ArrayList<Boolean> boolArrOne = new ArrayList<>();

  public int sizeBoolArrOne() {
    return this.boolArrOne.size();
  }

  public Boolean getBoolArrOne(int index) {
    if (index >= boolArrOne.size())
      return null;
    return this.boolArrOne.get(index);
  }

  public Boolean setBoolArrOne(int index, Boolean value) {
    if (index >= boolArrOne.size())
      return null;
    return this.boolArrOne.set(index, value);
  }

  public Boolean removeBoolArrOne(int index) {
    if (index >= boolArrOne.size())
      return null;
    return this.boolArrOne.remove(index);
  }

  public Boolean popFrontBoolArrOne() {
    if (0 == boolArrOne.size())
      return null;
    return this.boolArrOne.remove(0);
  }

  public void pushBackBoolArrOne(Boolean value) {
    this.boolArrOne.add(value);
  }

  public Iterator iteratorBoolArrOne() {
    return this.boolArrOne.iterator();
  }

  protected ArrayList<String> strArrOne = new ArrayList<>();

  public int sizeStrArrOne() {
    return this.strArrOne.size();
  }

  public String getStrArrOne(int index) {
    if (index >= strArrOne.size())
      return null;
    return this.strArrOne.get(index);
  }

  public String setStrArrOne(int index, String value) {
    if (index >= strArrOne.size())
      return null;
    return this.strArrOne.set(index, value);
  }

  public String removeStrArrOne(int index) {
    if (index >= strArrOne.size())
      return null;
    return this.strArrOne.remove(index);
  }

  public String popFrontStrArrOne() {
    if (0 == strArrOne.size())
      return null;
    return this.strArrOne.remove(0);
  }

  public void pushBackStrArrOne(String value) {
    this.strArrOne.add(value);
  }

  public Iterator iteratorStrArrOne() {
    return this.strArrOne.iterator();
  }

  protected ArrayList<Float> flArr = new ArrayList<>();

  public int sizeFlArr() {
    return this.flArr.size();
  }

  public Float getFlArr(int index) {
    if (index >= flArr.size())
      return null;
    return this.flArr.get(index);
  }

  public Float setFlArr(int index, Float value) {
    if (index >= flArr.size())
      return null;
    return this.flArr.set(index, value);
  }

  public Float removeFlArr(int index) {
    if (index >= flArr.size())
      return null;
    return this.flArr.remove(index);
  }

  public Float popFrontFlArr() {
    if (0 == flArr.size())
      return null;
    return this.flArr.remove(0);
  }

  public void pushBackFlArr(Float value) {
    this.flArr.add(value);
  }

  public Iterator iteratorFlArr() {
    return this.flArr.iterator();
  }

  protected ArrayList<Double> dblArrOne = new ArrayList<>();

  public int sizeDblArrOne() {
    return this.dblArrOne.size();
  }

  public Double getDblArrOne(int index) {
    if (index >= dblArrOne.size())
      return null;
    return this.dblArrOne.get(index);
  }

  public Double setDblArrOne(int index, Double value) {
    if (index >= dblArrOne.size())
      return null;
    return this.dblArrOne.set(index, value);
  }

  public Double removeDblArrOne(int index) {
    if (index >= dblArrOne.size())
      return null;
    return this.dblArrOne.remove(index);
  }

  public Double popFrontDblArrOne() {
    if (0 == dblArrOne.size())
      return null;
    return this.dblArrOne.remove(0);
  }

  public void pushBackDblArrOne(Double value) {
    this.dblArrOne.add(value);
  }

  public Iterator iteratorDblArrOne() {
    return this.dblArrOne.iterator();
  }

  protected ArrayList<Double> dblArrTwo = new ArrayList<>();

  public int sizeDblArrTwo() {
    return this.dblArrTwo.size();
  }

  public Double getDblArrTwo(int index) {
    if (index >= dblArrTwo.size())
      return null;
    return this.dblArrTwo.get(index);
  }

  public Double setDblArrTwo(int index, Double value) {
    if (index >= dblArrTwo.size())
      return null;
    return this.dblArrTwo.set(index, value);
  }

  public Double removeDblArrTwo(int index) {
    if (index >= dblArrTwo.size())
      return null;
    return this.dblArrTwo.remove(index);
  }

  public Double popFrontDblArrTwo() {
    if (0 == dblArrTwo.size())
      return null;
    return this.dblArrTwo.remove(0);
  }

  public void pushBackDblArrTwo(Double value) {
    this.dblArrTwo.add(value);
  }

  public Iterator iteratorDblArrTwo() {
    return this.dblArrTwo.iterator();
  }

}

********************************************************************************
package dev.riotjy.demoProject;
import java.util.ArrayList;
import java.util.Iterator;

@Entity
@Table(name = "ANNOTATED_TABLE")
public class AnnotatedClass {

  @GeneratedValue
  @Column(name = "id")
  @Id()
  protected Integer id;

  public Integer getId() {
    return this.id;
  }

  public void setId(Integer id) {
    this.id = id;
  }

  @ManyToAny(metaColumn = @Column(name = "property_type"))
  @JoinColumn(name="parent_id", insertable=false,
    updatable=false, nullable=false)   # using more spaces to indent the second line
  @OrderColumn(name="order")
  protected ArrayList<Integer> intArrExample = new ArrayList<>();

  public int sizeIntArrExample() {
    return this.intArrExample.size();
  }

  public Integer getIntArrExample(int index) {
    if (index >= intArrExample.size())
      return null;
    return this.intArrExample.get(index);
  }

  public Integer setIntArrExample(int index, Integer value) {
    if (index >= intArrExample.size())
      return null;
    return this.intArrExample.set(index, value);
  }

  public Integer removeIntArrExample(int index) {
    if (index >= intArrExample.size())
      return null;
    return this.intArrExample.remove(index);
  }

  public Integer popFrontIntArrExample() {
    if (0 == intArrExample.size())
      return null;
    return this.intArrExample.remove(0);
  }

  public void pushBackIntArrExample(Integer value) {
    this.intArrExample.add(value);
  }

  public Iterator iteratorIntArrExample() {
    return this.intArrExample.iterator();
  }

}

********************************************************************************
package dev.riotjy.demoProject;
public enum MjyPrimitiveType {
  BOOLEAN,
  CHAR,
  BYTE,
  SHORT,
  INT,
  LONG,
  FLOAT,
  DOUBLE,
  STRING,
  INVALID;
}

********************************************************************************
package dev.riotjy.demoProject;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Set;

import java.util.Iterator;
import dev.riotjy.demo.extclass.ExtClassJ;
import dev.riotjy.demo.extclass.ExtClass4CollJ;


public class DemoProjectSerializer {

  private static String serBaseClass(BaseClass value) {
    return
        lin(con(qtd("intBase"), serValue(value.intBase))) +
        lin(con(qtd("objBase"), serValue(value.objBase))) +
        lin(con(qtd("objArrBase"), serArr(value.objArrBase))) +
        con(qtd("objMapBase"), serMap(value.objMapBase));
  }
  private static String serDervClassOne(DervClassOne value) {
    return
        lin(serBaseClass(value)) +
        lin(con(qtd("intDervOne"), serValue(value.intDervOne))) +
        lin(con(qtd("strDervOne"), serValue(value.strDervOne))) +
        lin(con(qtd("objDervOne"), serArr(value.objDervOne))) +
        con(qtd("mapOneDervOne"), serMap(value.mapOneDervOne));
  }
  private static String serDervClassTwo(DervClassTwo value) {
    return
        lin(serDervClassOne(value)) +
        lin(con(qtd("intDervTwo"), serValue(value.intDervTwo))) +
        lin(con(qtd("strDervTwo"), serValue(value.strDervTwo))) +
        lin(con(qtd("objDervTwo"), serValue(value.objDervTwo))) +
        con(qtd("mapDervTwo"), serMap(value.mapDervTwo));
  }
  private static String serRefClassOne(RefClassOne value) {
    return
        lin(con(qtd("intRefOne"), serValue(value.intRefOne))) +
        con(qtd("strRefOne"), serValue(value.strRefOne));
  }
  private static String serRefClassTwo(RefClassTwo value) {
    return
        lin(con(qtd("intRefTwo"), serValue(value.intRefTwo))) +
        con(qtd("strRefTwo"), serValue(value.strRefTwo));
  }
  private static String serExternalClassType(ExternalClassType value) {
    return
        // TODO: REPLACE WITH SERIALIZATION CODE FOR CLASS ExternalClassType
        "";
  }
  private static String serExternalClassType4Coll(ExternalClassType4Coll value) {
    return
        // TODO: REPLACE WITH SERIALIZATION CODE FOR CLASS ExternalClassType4Coll
        "";
  }
  private static String serPrimitivesClass(PrimitivesClass value) {
    return
        lin(con(qtd("boolOne"), serValue(value.boolOne))) +
        lin(con(qtd("charOne"), serValue(value.charOne))) +
        lin(con(qtd("byteOne"), serValue(value.byteOne))) +
        lin(con(qtd("shortOne"), serValue(value.shortOne))) +
        lin(con(qtd("intOne"), serValue(value.intOne))) +
        lin(con(qtd("longOne"), serValue(value.longOne))) +
        lin(con(qtd("flOne"), serValue(value.flOne))) +
        lin(con(qtd("dblOne"), serValue(value.dblOne))) +
        lin(con(qtd("strOne"), serValue(value.strOne))) +
        lin(con(qtd("intTwo"), serValue(value.intTwo))) +
        lin(con(qtd("intThree"), serValue(value.intThree))) +
        lin(con(qtd("intArrOne"), serArr(value.intArrOne))) +
        lin(con(qtd("boolArrOne"), serArr(value.boolArrOne))) +
        lin(con(qtd("strArrOne"), serArr(value.strArrOne))) +
        lin(con(qtd("flArr"), serArr(value.flArr))) +
        lin(con(qtd("dblArrOne"), serArr(value.dblArrOne))) +
        con(qtd("dblArrTwo"), serArr(value.dblArrTwo));
  }
  private static String serAnnotatedClass(AnnotatedClass value) {
    return
        lin(con(qtd("id"), serValue(value.id))) +
        con(qtd("intArrExample"), serArr(value.intArrExample));
  }
  private static String serValue(Object value) {
    
    if (null == value)
      return "null";
    
    if (value instanceof Boolean ||
        value instanceof Integer ||
        value instanceof Float ||
        value instanceof Double) {
      return value.toString();
    }
    
    if (value instanceof String) {
      return "\"" + ((String)value).toString() + "\"";
    }

    String className = value.getClass().getSimpleName();
    switch(className) {
    case "BaseClass":
      return serClass(className,serBaseClass((BaseClass)value));
    case "DervClassOne":
      return serClass(className,serDervClassOne((DervClassOne)value));
    case "DervClassTwo":
      return serClass(className,serDervClassTwo((DervClassTwo)value));
    case "RefClassOne":
      return serClass(className,serRefClassOne((RefClassOne)value));
    case "RefClassTwo":
      return serClass(className,serRefClassTwo((RefClassTwo)value));
    case "ExternalClassType":
      return serClass(className,serExternalClassType((ExternalClassType)value));
    case "ExternalClassType4Coll":
      return serClass(className,serExternalClassType4Coll((ExternalClassType4Coll)value));
    case "PrimitivesClass":
      return serClass(className,serPrimitivesClass((PrimitivesClass)value));
    case "AnnotatedClass":
      return serClass(className,serAnnotatedClass((AnnotatedClass)value));
    default:
      return "";
    }
  }
  private static String serClass(String className, String fields) {
    String code = "{\"cnid\":" + qtd(className) + "";
    if (null != fields && !fields.isEmpty()) {
      code += "," + fields;
    }
    code += "}";
    return code;
  }

  private static String serArr(ArrayList<?> arr) {
    String json = "[";
    Iterator<?> it = arr.iterator();
    
    while (it.hasNext()) {
      Object val = it.next();
      if (it.hasNext()) {
        json += lin(serValue(val)); 
      } else {
        json += serValue(val); 
      }
    }
    
    json += "]";
    return json;
  }

  private static String serMap(HashMap<String, ?> hm) {
    String json = "{";

    Iterator<String> it = hm.keySet().iterator();
   
    while (it.hasNext()) {
      String key = it.next();
      Object val = hm.get(key);
      if (it.hasNext()) {
        json += lin(con(qtd(key), serValue(val))); 
      } else {
        json += con(qtd(key), serValue(val)); 
      }
    }
    
    json += "}";
    return json;
  }
  
  private static String qtd(String in) {
    return "\"" + in + "\"";
  }
  private static String con(String first, String second) {
    return first + ":" + second;
  }
  private static String lin(String in) {
    return in + ",";
  }
  private static String crl(String in) {
    return "{" + in + "}";
  }
  
  public static String serialize(Object value) {
    return serValue(value);
  }
}

********************************************************************************
package dev.riotjy.demoProject;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Set;

import java.util.Map.Entry;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import dev.riotjy.demo.extclass.ExtClassJ;
import dev.riotjy.demo.extclass.ExtClass4CollJ;


public class DemoProjectDeserializer {

  private static void deserBaseClass(JsonObject jo,BaseClass value) {
    value.intBase = jo.get("intBase").getAsInt();
    value.objBase = (RefClassOne)deserObject(jo.get("objBase").getAsJsonObject());
    value.objArrBase = deserArr(jo.get("objArrBase").getAsJsonArray(), null);
    value.objMapBase = deserMap(jo.get("objMapBase").getAsJsonObject(), null);
  }
  private static void deserDervClassOne(JsonObject jo,DervClassOne value) {
    deserBaseClass(jo, value);
    value.strDervOne = jo.get("strDervOne").getAsString();
    value.intDervOne = jo.get("intDervOne").getAsInt();
    value.objDervOne = deserArr(jo.get("objDervOne").getAsJsonArray(), null);
    value.mapOneDervOne = deserMap(jo.get("mapOneDervOne").getAsJsonObject(), null);
  }
  private static void deserDervClassTwo(JsonObject jo,DervClassTwo value) {
    deserDervClassOne(jo, value);
    value.strDervTwo = jo.get("strDervTwo").getAsString();
    value.objDervTwo = (ExternalClassType)deserObject(jo.get("objDervTwo").getAsJsonObject());
    value.intDervTwo = jo.get("intDervTwo").getAsInt();
    value.mapDervTwo = deserMap(jo.get("mapDervTwo").getAsJsonObject(), null);
  }
  private static void deserRefClassOne(JsonObject jo,RefClassOne value) {
    value.intRefOne = jo.get("intRefOne").getAsInt();
    value.strRefOne = jo.get("strRefOne").getAsString();
  }
  private static void deserRefClassTwo(JsonObject jo,RefClassTwo value) {
    value.strRefTwo = jo.get("strRefTwo").getAsString();
    value.intRefTwo = jo.get("intRefTwo").getAsInt();
  }
  private static void deserExternalClassType(JsonObject jo,ExternalClassType value) {
    // TODO: ADD DESERIALIZATION CODE HERE IF NECESSARY
  }
  private static void deserExternalClassType4Coll(JsonObject jo,ExternalClassType4Coll value) {
    // TODO: ADD DESERIALIZATION CODE HERE IF NECESSARY
  }
  private static void deserPrimitivesClass(JsonObject jo,PrimitivesClass value) {
    value.byteOne = jo.get("byteOne").getAsString();
    value.strOne = jo.get("strOne").getAsString();
    value.longOne = jo.get("longOne").getAsString();
    value.dblOne = jo.get("dblOne").getAsDouble();
    value.intThree = jo.get("intThree").getAsInt();
    value.boolOne = jo.get("boolOne").getAsBoolean();
    value.intOne = jo.get("intOne").getAsInt();
    value.charOne = jo.get("charOne").getAsString();
    value.intTwo = jo.get("intTwo").getAsInt();
    value.shortOne = jo.get("shortOne").getAsString();
    value.flOne = jo.get("flOne").getAsFloat();
    value.flArr = deserArr(jo.get("flArr").getAsJsonArray(), MjyPrimitiveType.FLOAT);
    value.strArrOne = deserArr(jo.get("strArrOne").getAsJsonArray(), MjyPrimitiveType.STRING);
    value.dblArrOne = deserArr(jo.get("dblArrOne").getAsJsonArray(), MjyPrimitiveType.DOUBLE);
    value.intArrOne = deserArr(jo.get("intArrOne").getAsJsonArray(), MjyPrimitiveType.INT);
    value.boolArrOne = deserArr(jo.get("boolArrOne").getAsJsonArray(), MjyPrimitiveType.BOOLEAN);
    value.dblArrTwo = deserArr(jo.get("dblArrTwo").getAsJsonArray(), MjyPrimitiveType.DOUBLE);
  }
  private static void deserAnnotatedClass(JsonObject jo,AnnotatedClass value) {
    value.id = jo.get("id").getAsInt();
    value.intArrExample = deserArr(jo.get("intArrExample").getAsJsonArray(), MjyPrimitiveType.INT);
  }
  private static Object deserObject(JsonObject jo) {
    
    String cnid = jo.get("cnid").getAsString();
    
    switch (cnid) {
    case "BaseClass": {
      BaseClass obj = new BaseClass();
      deserBaseClass(jo ,obj);
      return obj; }
    case "DervClassOne": {
      DervClassOne obj = new DervClassOne();
      deserDervClassOne(jo ,obj);
      return obj; }
    case "DervClassTwo": {
      DervClassTwo obj = new DervClassTwo();
      deserDervClassTwo(jo ,obj);
      return obj; }
    case "RefClassOne": {
      RefClassOne obj = new RefClassOne();
      deserRefClassOne(jo ,obj);
      return obj; }
    case "RefClassTwo": {
      RefClassTwo obj = new RefClassTwo();
      deserRefClassTwo(jo ,obj);
      return obj; }
    case "ExternalClassType": {
      ExternalClassType obj = new ExternalClassType();
      deserExternalClassType(jo ,obj);
      return obj; }
    case "ExternalClassType4Coll": {
      ExternalClassType4Coll obj = new ExternalClassType4Coll();
      deserExternalClassType4Coll(jo ,obj);
      return obj; }
    case "PrimitivesClass": {
      PrimitivesClass obj = new PrimitivesClass();
      deserPrimitivesClass(jo ,obj);
      return obj; }
    case "AnnotatedClass": {
      AnnotatedClass obj = new AnnotatedClass();
      deserAnnotatedClass(jo ,obj);
      return obj; }
    default:
      return null;
    }
  }
  private static Object deserPrimitive(JsonPrimitive jp, MjyPrimitiveType prType) {
    if (null == prType) {
      return jp.getAsString();
    }
    switch (prType) {
    case BOOLEAN:
      return Boolean.valueOf(jp.getAsBoolean());
    case INT:
      return Integer.valueOf(jp.getAsInt());
    case FLOAT:
      return Float.valueOf(jp.getAsFloat());
    case DOUBLE:
      return Double.valueOf(jp.getAsDouble());
    case STRING:
      return jp.getAsString();
    }
    return null;
  }

  private static ArrayList deserArr(JsonArray ja, MjyPrimitiveType prType) {
    ArrayList<Object> arr = new ArrayList<Object>();
    
    for (JsonElement el : ja) {
      if (el.isJsonObject())
      {
        arr.add(deserObject(el.getAsJsonObject()));
        continue;
      }
      if (el.isJsonPrimitive()) {
        arr.add(deserPrimitive(el.getAsJsonPrimitive(), prType));
      }
    }
    
    return arr;
  }

  private static HashMap deserMap(JsonObject jo, MjyPrimitiveType prType) {
    HashMap<String, Object> hm = new HashMap<>();
    
    Iterator<Entry<String, JsonElement>> it = jo.entrySet().iterator();
    
    while (it.hasNext()) {
      Entry<String, JsonElement> en = it.next();
      JsonElement el = en.getValue();
      if (el.isJsonObject()) {
        hm.put(en.getKey(), deserObject(el.getAsJsonObject()));
        continue;
      }
      if (el.isJsonPrimitive()) {
        hm.put(en.getKey(), deserPrimitive(el.getAsJsonPrimitive(), prType));
      }
    }
    
    return hm;
  }

  public static Object deserialize(JsonObject jo) {
    return deserObject(jo);
  }
  
  public static Object deserialize(String json) {
    return deserialize(new JsonParser().parse(json).getAsJsonObject());
  }
}
```

## C++ output (C++11):

```CPP
#include <cstdint>
#include <string>
class IMjyRoot {
public:
  virtual ~IMjyRoot() {}
  virtual std::string className() = 0;
};
#pragma once
#ifndef IMjyRoot_hpp
#define IMjyRoot_hpp

#endif // IMjyRoot_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include <stdexcept>
#include <vector>
#include <map>
#include <memory>
#include "RefClassOne.hpp"
#include "RefClassTwo.hpp"
#include "IMjyRoot.hpp"


#pragma once
#ifndef BaseClass_hpp
#define BaseClass_hpp

namespace demoproject {

class BaseClass: public IMjyRoot {
public:
  virtual std::string className() {return "BaseClass";}

public:
  int32_t intBase;
public:
  int32_t getIntBase() {
    return this->intBase;
  }

  void setIntBase(int32_t intBase) {
    this->intBase = intBase;
  }

public:
  std::shared_ptr<RefClassOne> objBase = nullptr;
public:
  std::shared_ptr<RefClassOne> getObjBase() {
    return this->objBase;
  }

  void setObjBase(std::shared_ptr<RefClassOne> objBase) {
    this->objBase = objBase;
  }

public:
  std::vector<std::shared_ptr<RefClassTwo>> objArrBase;

public:
  std::vector<std::shared_ptr<RefClassTwo>>::size_type sizeObjArrBase() {
    return this->objArrBase.size();
  }

  std::shared_ptr<RefClassTwo> & atObjArrBase(std::vector<std::shared_ptr<RefClassTwo>>::size_type pos) {
    if (pos >= objArrBase.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->objArrBase.at(pos);
  }

  std::shared_ptr<RefClassTwo> popFrontObjArrBase() {
    if (0 == objArrBase.size())
      throw std::length_error("Vector is empty!");
    std::shared_ptr<RefClassTwo> ret = this->objArrBase.front();
    this->objArrBase.erase(objArrBase.begin());
    return ret;
  }

  void pushBackObjArrBase(std::shared_ptr<RefClassTwo> value) {
    this->objArrBase.push_back(value);
  }

  std::vector<std::shared_ptr<RefClassTwo>>::const_iterator iteratorObjArrBase() {
    return this->objArrBase.cbegin();
  }

public:
  std::map<std::string, std::shared_ptr<RefClassTwo>> objMapBase;

public:
  std::map<std::string, std::shared_ptr<RefClassTwo>>::size_type sizeObjMapBase() {
    return this->objMapBase.size();
  }

  std::shared_ptr<RefClassTwo> & getObjMapBase(std::string key) {
    return this->objMapBase[key];
  }

  bool putObjMapBase(std::string key, std::shared_ptr<RefClassTwo> value) {
    auto retPair = this->objMapBase.emplace(key, value);
    return retPair.second;
  }

  std::map<std::string, std::shared_ptr<RefClassTwo>>::size_type eraseObjMapBase(std::string key) {
    return this->objMapBase.erase(key);
  }

  std::map<std::string, std::shared_ptr<RefClassTwo>>::const_iterator iteratorObjMapBase() {
    return this->objMapBase.cbegin();
  }

}; // class BaseClass


} // namespace demoproject
#endif // BaseClass_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include <stdexcept>
#include <vector>
#include <map>
#include <memory>
#include "RefClassOne.hpp"
#include "RefClassTwo.hpp"
#include "BaseClass.hpp"


#pragma once
#ifndef DervClassOne_hpp
#define DervClassOne_hpp

namespace demoproject {

class DervClassOne: public BaseClass {
public:
  virtual std::string className() {return "DervClassOne";}

public:
  int32_t intDervOne;
public:
  int32_t getIntDervOne() {
    return this->intDervOne;
  }

  void setIntDervOne(int32_t intDervOne) {
    this->intDervOne = intDervOne;
  }

public:
  std::string strDervOne;
public:
  std::string getStrDervOne() {
    return this->strDervOne;
  }

  void setStrDervOne(std::string strDervOne) {
    this->strDervOne = strDervOne;
  }

public:
  std::vector<std::shared_ptr<RefClassOne>> objDervOne;

public:
  std::vector<std::shared_ptr<RefClassOne>>::size_type sizeObjDervOne() {
    return this->objDervOne.size();
  }

  std::shared_ptr<RefClassOne> & atObjDervOne(std::vector<std::shared_ptr<RefClassOne>>::size_type pos) {
    if (pos >= objDervOne.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->objDervOne.at(pos);
  }

  std::shared_ptr<RefClassOne> popFrontObjDervOne() {
    if (0 == objDervOne.size())
      throw std::length_error("Vector is empty!");
    std::shared_ptr<RefClassOne> ret = this->objDervOne.front();
    this->objDervOne.erase(objDervOne.begin());
    return ret;
  }

  void pushBackObjDervOne(std::shared_ptr<RefClassOne> value) {
    this->objDervOne.push_back(value);
  }

  std::vector<std::shared_ptr<RefClassOne>>::const_iterator iteratorObjDervOne() {
    return this->objDervOne.cbegin();
  }

public:
  std::map<std::string, std::shared_ptr<RefClassTwo>> mapOneDervOne;

public:
  std::map<std::string, std::shared_ptr<RefClassTwo>>::size_type sizeMapOneDervOne() {
    return this->mapOneDervOne.size();
  }

  std::shared_ptr<RefClassTwo> & getMapOneDervOne(std::string key) {
    return this->mapOneDervOne[key];
  }

  bool putMapOneDervOne(std::string key, std::shared_ptr<RefClassTwo> value) {
    auto retPair = this->mapOneDervOne.emplace(key, value);
    return retPair.second;
  }

  std::map<std::string, std::shared_ptr<RefClassTwo>>::size_type eraseMapOneDervOne(std::string key) {
    return this->mapOneDervOne.erase(key);
  }

  std::map<std::string, std::shared_ptr<RefClassTwo>>::const_iterator iteratorMapOneDervOne() {
    return this->mapOneDervOne.cbegin();
  }

}; // class DervClassOne


} // namespace demoproject
#endif // DervClassOne_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include <stdexcept>
#include <map>
#include <memory>
#include "ExternalClassType.hpp"
#include "ExternalClassType4Coll.hpp"
#include "DervClassOne.hpp"


#pragma once
#ifndef DervClassTwo_hpp
#define DervClassTwo_hpp

namespace demoproject {

class DervClassTwo: public DervClassOne {
public:
  virtual std::string className() {return "DervClassTwo";}

public:
  int32_t intDervTwo;
public:
  int32_t getIntDervTwo() {
    return this->intDervTwo;
  }

  void setIntDervTwo(int32_t intDervTwo) {
    this->intDervTwo = intDervTwo;
  }

public:
  std::string strDervTwo;
public:
  std::string getStrDervTwo() {
    return this->strDervTwo;
  }

  void setStrDervTwo(std::string strDervTwo) {
    this->strDervTwo = strDervTwo;
  }

public:
  std::shared_ptr<ExternalClassType> objDervTwo = nullptr;
public:
  std::shared_ptr<ExternalClassType> getObjDervTwo() {
    return this->objDervTwo;
  }

  void setObjDervTwo(std::shared_ptr<ExternalClassType> objDervTwo) {
    this->objDervTwo = objDervTwo;
  }

public:
  std::map<std::string, std::shared_ptr<ExternalClassType4Coll>> mapDervTwo;

public:
  std::map<std::string, std::shared_ptr<ExternalClassType4Coll>>::size_type sizeMapDervTwo() {
    return this->mapDervTwo.size();
  }

  std::shared_ptr<ExternalClassType4Coll> & getMapDervTwo(std::string key) {
    return this->mapDervTwo[key];
  }

  bool putMapDervTwo(std::string key, std::shared_ptr<ExternalClassType4Coll> value) {
    auto retPair = this->mapDervTwo.emplace(key, value);
    return retPair.second;
  }

  std::map<std::string, std::shared_ptr<ExternalClassType4Coll>>::size_type eraseMapDervTwo(std::string key) {
    return this->mapDervTwo.erase(key);
  }

  std::map<std::string, std::shared_ptr<ExternalClassType4Coll>>::const_iterator iteratorMapDervTwo() {
    return this->mapDervTwo.cbegin();
  }

}; // class DervClassTwo


} // namespace demoproject
#endif // DervClassTwo_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include "IMjyRoot.hpp"


#pragma once
#ifndef RefClassOne_hpp
#define RefClassOne_hpp

namespace demoproject {

class RefClassOne: public IMjyRoot {
public:
  virtual std::string className() {return "RefClassOne";}

public:
  int32_t intRefOne;
public:
  int32_t getIntRefOne() {
    return this->intRefOne;
  }

  void setIntRefOne(int32_t intRefOne) {
    this->intRefOne = intRefOne;
  }

public:
  std::string strRefOne;
public:
  std::string getStrRefOne() {
    return this->strRefOne;
  }

  void setStrRefOne(std::string strRefOne) {
    this->strRefOne = strRefOne;
  }

}; // class RefClassOne


} // namespace demoproject
#endif // RefClassOne_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include "IMjyRoot.hpp"


#pragma once
#ifndef RefClassTwo_hpp
#define RefClassTwo_hpp

namespace demoproject {

class RefClassTwo: public IMjyRoot {
public:
  virtual std::string className() {return "RefClassTwo";}

public:
  int32_t intRefTwo;
public:
  int32_t getIntRefTwo() {
    return this->intRefTwo;
  }

  void setIntRefTwo(int32_t intRefTwo) {
    this->intRefTwo = intRefTwo;
  }

public:
  std::string strRefTwo;
public:
  std::string getStrRefTwo() {
    return this->strRefTwo;
  }

  void setStrRefTwo(std::string strRefTwo) {
    this->strRefTwo = strRefTwo;
  }

}; // class RefClassTwo


} // namespace demoproject
#endif // RefClassTwo_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include "ext/ExtClassCpp.hpp"


#pragma once
#ifndef ExternalClassType_hpp
#define ExternalClassType_hpp

namespace demoproject {

class ExternalClassType : public IMjyRoot, ExtClassCpp {
public:
  virtual std::string className() {return "ExternalClassType";}

  // TODO: ADD ANY NECESSARY CODE FOR DE-/SERIALIZATION OF ExtClassCpp

}; // class ExternalClassType


} // namespace demoproject
#endif // ExternalClassType_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include "ext/ExtClass4CollCpp.hpp"


#pragma once
#ifndef ExternalClassType4Coll_hpp
#define ExternalClassType4Coll_hpp

namespace demoproject {

class ExternalClassType4Coll : public IMjyRoot, ExtClass4CollCpp {
public:
  virtual std::string className() {return "ExternalClassType4Coll";}

  // TODO: ADD ANY NECESSARY CODE FOR DE-/SERIALIZATION OF ExtClass4CollCpp

}; // class ExternalClassType4Coll


} // namespace demoproject
#endif // ExternalClassType4Coll_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include <stdexcept>
#include <vector>
#include "IMjyRoot.hpp"


#pragma once
#ifndef PrimitivesClass_hpp
#define PrimitivesClass_hpp

namespace demoproject {

class PrimitivesClass: public IMjyRoot {
public:
  virtual std::string className() {return "PrimitivesClass";}

public:
  bool boolOne;
public:
  bool getBoolOne() {
    return this->boolOne;
  }

  void setBoolOne(bool boolOne) {
    this->boolOne = boolOne;
  }

public:
  char16_t charOne;
public:
  char16_t getCharOne() {
    return this->charOne;
  }

  void setCharOne(char16_t charOne) {
    this->charOne = charOne;
  }

public:
  int8_t byteOne;
public:
  int8_t getByteOne() {
    return this->byteOne;
  }

  void setByteOne(int8_t byteOne) {
    this->byteOne = byteOne;
  }

public:
  int16_t shortOne;
public:
  int16_t getShortOne() {
    return this->shortOne;
  }

  void setShortOne(int16_t shortOne) {
    this->shortOne = shortOne;
  }

public:
  int32_t intOne;
public:
  int32_t getIntOne() {
    return this->intOne;
  }

  void setIntOne(int32_t intOne) {
    this->intOne = intOne;
  }

public:
  int64_t longOne;
public:
  int64_t getLongOne() {
    return this->longOne;
  }

  void setLongOne(int64_t longOne) {
    this->longOne = longOne;
  }

public:
  float flOne;
public:
  float getFlOne() {
    return this->flOne;
  }

  void setFlOne(float flOne) {
    this->flOne = flOne;
  }

public:
  double dblOne;
public:
  double getDblOne() {
    return this->dblOne;
  }

  void setDblOne(double dblOne) {
    this->dblOne = dblOne;
  }

public:
  std::string strOne;
public:
  std::string getStrOne() {
    return this->strOne;
  }

  void setStrOne(std::string strOne) {
    this->strOne = strOne;
  }

public:
  int32_t intTwo;
public:
  int32_t getIntTwo() {
    return this->intTwo;
  }

  void setIntTwo(int32_t intTwo) {
    this->intTwo = intTwo;
  }

public:
  int32_t intThree;
public:
  int32_t getIntThree() {
    return this->intThree;
  }

  void setIntThree(int32_t intThree) {
    this->intThree = intThree;
  }

public:
  std::vector<int32_t> intArrOne;

public:
  std::vector<int32_t>::size_type sizeIntArrOne() {
    return this->intArrOne.size();
  }

  int32_t & atIntArrOne(std::vector<int32_t>::size_type pos) {
    if (pos >= intArrOne.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->intArrOne.at(pos);
  }

  int32_t popFrontIntArrOne() {
    if (0 == intArrOne.size())
      throw std::length_error("Vector is empty!");
    int32_t ret = this->intArrOne.front();
    this->intArrOne.erase(intArrOne.begin());
    return ret;
  }

  void pushBackIntArrOne(int32_t value) {
    this->intArrOne.push_back(value);
  }

  std::vector<int32_t>::const_iterator iteratorIntArrOne() {
    return this->intArrOne.cbegin();
  }

public:
  std::vector<bool> boolArrOne;

public:
  std::vector<bool>::size_type sizeBoolArrOne() {
    return this->boolArrOne.size();
  }

  bool atBoolArrOne(std::vector<bool>::size_type pos) {
    if (pos >= boolArrOne.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->boolArrOne.at(pos);
  }

  bool popFrontBoolArrOne() {
    if (0 == boolArrOne.size())
      throw std::length_error("Vector is empty!");
    bool ret = this->boolArrOne.front();
    this->boolArrOne.erase(boolArrOne.begin());
    return ret;
  }

  void pushBackBoolArrOne(bool value) {
    this->boolArrOne.push_back(value);
  }

  std::vector<bool>::const_iterator iteratorBoolArrOne() {
    return this->boolArrOne.cbegin();
  }

public:
  std::vector<std::string> strArrOne;

public:
  std::vector<std::string>::size_type sizeStrArrOne() {
    return this->strArrOne.size();
  }

  std::string & atStrArrOne(std::vector<std::string>::size_type pos) {
    if (pos >= strArrOne.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->strArrOne.at(pos);
  }

  std::string popFrontStrArrOne() {
    if (0 == strArrOne.size())
      throw std::length_error("Vector is empty!");
    std::string ret = this->strArrOne.front();
    this->strArrOne.erase(strArrOne.begin());
    return ret;
  }

  void pushBackStrArrOne(std::string value) {
    this->strArrOne.push_back(value);
  }

  std::vector<std::string>::const_iterator iteratorStrArrOne() {
    return this->strArrOne.cbegin();
  }

public:
  std::vector<float> flArr;

public:
  std::vector<float>::size_type sizeFlArr() {
    return this->flArr.size();
  }

  float & atFlArr(std::vector<float>::size_type pos) {
    if (pos >= flArr.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->flArr.at(pos);
  }

  float popFrontFlArr() {
    if (0 == flArr.size())
      throw std::length_error("Vector is empty!");
    float ret = this->flArr.front();
    this->flArr.erase(flArr.begin());
    return ret;
  }

  void pushBackFlArr(float value) {
    this->flArr.push_back(value);
  }

  std::vector<float>::const_iterator iteratorFlArr() {
    return this->flArr.cbegin();
  }

public:
  std::vector<double> dblArrOne;

public:
  std::vector<double>::size_type sizeDblArrOne() {
    return this->dblArrOne.size();
  }

  double & atDblArrOne(std::vector<double>::size_type pos) {
    if (pos >= dblArrOne.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->dblArrOne.at(pos);
  }

  double popFrontDblArrOne() {
    if (0 == dblArrOne.size())
      throw std::length_error("Vector is empty!");
    double ret = this->dblArrOne.front();
    this->dblArrOne.erase(dblArrOne.begin());
    return ret;
  }

  void pushBackDblArrOne(double value) {
    this->dblArrOne.push_back(value);
  }

  std::vector<double>::const_iterator iteratorDblArrOne() {
    return this->dblArrOne.cbegin();
  }

public:
  std::vector<double> dblArrTwo;

public:
  std::vector<double>::size_type sizeDblArrTwo() {
    return this->dblArrTwo.size();
  }

  double & atDblArrTwo(std::vector<double>::size_type pos) {
    if (pos >= dblArrTwo.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->dblArrTwo.at(pos);
  }

  double popFrontDblArrTwo() {
    if (0 == dblArrTwo.size())
      throw std::length_error("Vector is empty!");
    double ret = this->dblArrTwo.front();
    this->dblArrTwo.erase(dblArrTwo.begin());
    return ret;
  }

  void pushBackDblArrTwo(double value) {
    this->dblArrTwo.push_back(value);
  }

  std::vector<double>::const_iterator iteratorDblArrTwo() {
    return this->dblArrTwo.cbegin();
  }

}; // class PrimitivesClass


} // namespace demoproject
#endif // PrimitivesClass_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include <stdexcept>
#include <vector>
#include "IMjyRoot.hpp"


#pragma once
#ifndef AnnotatedClass_hpp
#define AnnotatedClass_hpp

namespace demoproject {

class AnnotatedClass: public IMjyRoot {
public:
  virtual std::string className() {return "AnnotatedClass";}

public:
  int32_t id;
public:
  int32_t getId() {
    return this->id;
  }

  void setId(int32_t id) {
    this->id = id;
  }

public:
  std::vector<int32_t> intArrExample;

public:
  std::vector<int32_t>::size_type sizeIntArrExample() {
    return this->intArrExample.size();
  }

  int32_t & atIntArrExample(std::vector<int32_t>::size_type pos) {
    if (pos >= intArrExample.size())
      throw std::invalid_argument("Vector position/index out of bounds!");
    return this->intArrExample.at(pos);
  }

  int32_t popFrontIntArrExample() {
    if (0 == intArrExample.size())
      throw std::length_error("Vector is empty!");
    int32_t ret = this->intArrExample.front();
    this->intArrExample.erase(intArrExample.begin());
    return ret;
  }

  void pushBackIntArrExample(int32_t value) {
    this->intArrExample.push_back(value);
  }

  std::vector<int32_t>::const_iterator iteratorIntArrExample() {
    return this->intArrExample.cbegin();
  }

}; // class AnnotatedClass


} // namespace demoproject
#endif // AnnotatedClass_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include <stdexcept>
#include <vector>
#include <map>
#include <iterator>
#include "json.hpp"
#include "BaseClass.hpp"
#include "DervClassOne.hpp"
#include "DervClassTwo.hpp"
#include "RefClassOne.hpp"
#include "RefClassTwo.hpp"
#include "ExternalClassType.hpp"
#include "ExternalClassType4Coll.hpp"
#include "PrimitivesClass.hpp"
#include "AnnotatedClass.hpp"


#pragma once
#ifndef DemoProjectSerializer_hpp
#define DemoProjectSerializer_hpp

namespace demoproject {

class DemoProjectSerializer: public IMjyRoot {
public:
  virtual std::string className() {return "DemoProjectSerializer";}

private:
  std::string serBaseClass(BaseClass * value) {
    return
        lin(con(qtd("intBase"), std::to_string(value->intBase))) +
        lin(con(qtd("objBase"), serCValue(value->objBase.get()))) +
        lin(con(qtd("objArrBase"), serArr(value->objArrBase))) +
        con(qtd("objMapBase"), serMap(value->objMapBase));
  }

private:
  std::string serDervClassOne(DervClassOne * value) {
    return
        lin(serBaseClass(value)) +
        lin(con(qtd("strDervOne"), qtd(value->strDervOne))) +
        lin(con(qtd("intDervOne"), std::to_string(value->intDervOne))) +
        lin(con(qtd("objDervOne"), serArr(value->objDervOne))) +
        con(qtd("mapOneDervOne"), serMap(value->mapOneDervOne));
  }

private:
  std::string serDervClassTwo(DervClassTwo * value) {
    return
        lin(serDervClassOne(value)) +
        lin(con(qtd("strDervTwo"), qtd(value->strDervTwo))) +
        lin(con(qtd("objDervTwo"), serCValue(value->objDervTwo.get()))) +
        lin(con(qtd("intDervTwo"), std::to_string(value->intDervTwo))) +
        con(qtd("mapDervTwo"), serMap(value->mapDervTwo));
  }

private:
  std::string serRefClassOne(RefClassOne * value) {
    return
        lin(con(qtd("intRefOne"), std::to_string(value->intRefOne))) +
        con(qtd("strRefOne"), qtd(value->strRefOne));
  }

private:
  std::string serRefClassTwo(RefClassTwo * value) {
    return
        lin(con(qtd("strRefTwo"), qtd(value->strRefTwo))) +
        con(qtd("intRefTwo"), std::to_string(value->intRefTwo));
  }

private:
  std::string serExternalClassType(ExternalClassType * value) {
    return
        // TODO: REPLACE WITH SERIALIZATION CODE FOR CLASS ExternalClassType AS NECESSARY! VERIFY CLASS DEFINITION.
        "";
  }

private:
  std::string serExternalClassType4Coll(ExternalClassType4Coll * value) {
    return
        // TODO: REPLACE WITH SERIALIZATION CODE FOR CLASS ExternalClassType4Coll AS NECESSARY! VERIFY CLASS DEFINITION.
        "";
  }

private:
  std::string serPrimitivesClass(PrimitivesClass * value) {
    return
        lin(con(qtd("byteOne"), std::to_string(value->byteOne))) +
        lin(con(qtd("strOne"), qtd(value->strOne))) +
        lin(con(qtd("longOne"), std::to_string(value->longOne))) +
        lin(con(qtd("dblOne"), std::to_string(value->dblOne))) +
        lin(con(qtd("intThree"), std::to_string(value->intThree))) +
        lin(con(qtd("boolOne"), serBool(value->boolOne))) +
        lin(con(qtd("intOne"), std::to_string(value->intOne))) +
        lin(con(qtd("charOne"), std::to_string(value->charOne))) +
        lin(con(qtd("intTwo"), std::to_string(value->intTwo))) +
        lin(con(qtd("shortOne"), std::to_string(value->shortOne))) +
        lin(con(qtd("flOne"), std::to_string(value->flOne))) +
        lin(con(qtd("flArr"), serArr(value->flArr))) +
        lin(con(qtd("strArrOne"), serArr(value->strArrOne))) +
        lin(con(qtd("dblArrOne"), serArr(value->dblArrOne))) +
        lin(con(qtd("intArrOne"), serArr(value->intArrOne))) +
        lin(con(qtd("boolArrOne"), serArr(value->boolArrOne))) +
        con(qtd("dblArrTwo"), serArr(value->dblArrTwo));
  }

private:
  std::string serAnnotatedClass(AnnotatedClass * value) {
    return
        lin(con(qtd("id"), std::to_string(value->id))) +
        con(qtd("intArrExample"), serArr(value->intArrExample));
  }

private:
  std::string serCValue(IMjyRoot* val) {
    if(val->className() == "BaseClass") {
        return serClass(val->className(), serBaseClass(dynamic_cast<BaseClass*>(val)));
    }
    if(val->className() == "DervClassOne") {
        return serClass(val->className(), serDervClassOne(dynamic_cast<DervClassOne*>(val)));
    }
    if(val->className() == "DervClassTwo") {
        return serClass(val->className(), serDervClassTwo(dynamic_cast<DervClassTwo*>(val)));
    }
    if(val->className() == "RefClassOne") {
        return serClass(val->className(), serRefClassOne(dynamic_cast<RefClassOne*>(val)));
    }
    if(val->className() == "RefClassTwo") {
        return serClass(val->className(), serRefClassTwo(dynamic_cast<RefClassTwo*>(val)));
    }
    if(val->className() == "ExternalClassType") {
        return serClass(val->className(), serExternalClassType(dynamic_cast<ExternalClassType*>(val)));
    }
    if(val->className() == "ExternalClassType4Coll") {
        return serClass(val->className(), serExternalClassType4Coll(dynamic_cast<ExternalClassType4Coll*>(val)));
    }
    if(val->className() == "PrimitivesClass") {
        return serClass(val->className(), serPrimitivesClass(dynamic_cast<PrimitivesClass*>(val)));
    }
    if(val->className() == "AnnotatedClass") {
        return serClass(val->className(), serAnnotatedClass(dynamic_cast<AnnotatedClass*>(val)));
    }
    return "";  }

private:
  std::string qtd(std::string in) {
    return "\"" + in + "\"";
  }
  std::string con(std::string first, std::string second) {
    return first + ":" + second;
  }
  std::string lin(std::string in) {
    return in + ",";
  }
  std::string crl(std::string in) {
    return "{" + in + "}";
  }
  
  std::string serClass(std::string className, std::string fields) {
    std::string json =  "{\"cnid\":\"" + className + "\"";
    if (!fields.empty()) {
      json += "," + fields;
    }
    json += "}";
    return json;
  }
  
  std::string serBool(bool val) {
    return val ? "true" : "false";
  }

  template <typename T>
  std::string serArr(std::vector<std::shared_ptr<T>> arr) {
    std::string json = "[";
    typename std::vector<std::shared_ptr<T>>::const_iterator it = arr.cbegin();
  
    while (it != arr.cend()) {
      if (it != --arr.cend()) {
        json += lin(serCValue(it->get()));
      } else {
        json += serCValue(it->get());
      }
      ++it;
    }
  
    json += "]";
    return json;
  }
  
  template <typename T>
  std::string serArr(std::vector<T> arr) {
  
    int arrSize = arr.size();
    std::string json = "[";
  
    for (int i = 0; i < arrSize; ++i) {
      T val = arr[i];
      if (i < arrSize - 1) {
        json += lin(std::to_string(val));
      } else {
        json += std::to_string(val);
      }
    }
  
    json += "]";
    return json;
  }

  std::string serArr(std::vector<bool> arr) {

    int arrSize = arr.size();
    std::string json = "[";

    for (int i = 0; i < arrSize; ++i) {
      bool val = arr[i];
      if (i < arrSize - 1) {
        json += lin(serBool(val));
      } else {
        json += serBool(val);
      }
    }

    json += "]";
    return json;
  }
  
  std::string serArr(std::vector<std::string> arr) {
  
    int arrSize = arr.size();
    std::string json = "[";
  
    for (int i = 0; i < arrSize; ++i) {
      std::string val = arr[i];
      if (i < arrSize - 1) {
        json += lin(qtd(val));
      } else {
        json += qtd(val);
      }
    }
  
    json += "]";
    return json;
  }
  
  template <typename T>
  std::string serMap(std::map<std::string, std::shared_ptr<T>> hm) {
    std::string json = "{";
  
    typename std::map<std::string, std::shared_ptr<T>>::const_iterator it = hm.cbegin();
  
    while (it != hm.cend()) {
      if (it != --hm.cend()) {
        json += lin(con(qtd(it->first), serCValue(it->second.get())));
      } else {
        json += con(qtd(it->first), serCValue(it->second.get()));
      }
      ++it;
    }
  
    json += "}";
    return json;
  }
  
  
  template <typename T>
  std::string serMap(std::map<std::string, T> map) {
    std::string json = "{";
  
    typename std::map<std::string, T>::const_iterator it = map.cbegin();
  
    while (it != map.cend()) {
      if (it != --map.cend()) {
        json += lin(con(qtd(it->first), std::to_string(it->second)));
      } else {
        json += con(qtd(it->first), std::to_string(it->second));
      }
      ++it;
    }
  
    json += "}";
    return json;
  }
  
  std::string serMap(std::map<std::string, bool> map) {
    std::string json = "{";

    std::map<std::string, bool>::const_iterator it = map.cbegin();

    while (it != map.cend()) {
      if (it != --map.cend()) {
        json += lin(con(qtd(it->first), serBool(it->second)));
      } else {
        json += con(qtd(it->first), serBool(it->second));
      }
      ++it;
    }
  }

  std::string serMap(std::map<std::string, std::string> map) {
    std::string json = "{";
  
    std::map<std::string, std::string>::const_iterator it = map.cbegin();
  
    while (it != map.cend()) {
      if (it != --map.cend()) {
        json += lin(con(qtd(it->first), qtd(it->second)));
      } else {
        json += con(qtd(it->first), qtd(it->second));
      }
      ++it;
    }
  
    json += "}";
    return json;
  }
public:
  std::string serialize(IMjyRoot& val) {
    return serCValue(&val);
  }

}; // class DemoProjectSerializer


} // namespace demoproject
#endif // DemoProjectSerializer_hpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <cstdint>
#include <string>
#include <stdexcept>
#include <vector>
#include <map>
#include <iterator>
#include <memory>
#include "json.hpp"
#include "BaseClass.hpp"
#include "DervClassOne.hpp"
#include "DervClassTwo.hpp"
#include "RefClassOne.hpp"
#include "RefClassTwo.hpp"
#include "ExternalClassType.hpp"
#include "ExternalClassType4Coll.hpp"
#include "PrimitivesClass.hpp"
#include "AnnotatedClass.hpp"


#pragma once
#ifndef DemoProjectDeserializer_hpp
#define DemoProjectDeserializer_hpp

namespace demoproject {

class DemoProjectDeserializer: public IMjyRoot {
public:
  virtual std::string className() {return "DemoProjectDeserializer";}

  void deserBaseClass(jsonl::json & jo,BaseClass * value) {
    value->intBase = jo["intBase"];
    value->objBase = std::dynamic_pointer_cast<RefClassOne>(deserObject(jo["objBase"]));
    deserArr(jo["objArrBase"], value->objArrBase);
    deserMap(jo["objMapBase"], value->objMapBase);
  }

  void deserDervClassOne(jsonl::json & jo,DervClassOne * value) {
    deserBaseClass(jo, value);
    value->strDervOne = jo["strDervOne"];
    value->intDervOne = jo["intDervOne"];
    deserArr(jo["objDervOne"], value->objDervOne);
    deserMap(jo["mapOneDervOne"], value->mapOneDervOne);
  }

  void deserDervClassTwo(jsonl::json & jo,DervClassTwo * value) {
    deserDervClassOne(jo, value);
    value->strDervTwo = jo["strDervTwo"];
    value->objDervTwo = std::dynamic_pointer_cast<ExternalClassType>(deserObject(jo["objDervTwo"]));
    value->intDervTwo = jo["intDervTwo"];
    deserMap(jo["mapDervTwo"], value->mapDervTwo);
  }

  void deserRefClassOne(jsonl::json & jo,RefClassOne * value) {
    value->intRefOne = jo["intRefOne"];
    value->strRefOne = jo["strRefOne"];
  }

  void deserRefClassTwo(jsonl::json & jo,RefClassTwo * value) {
    value->strRefTwo = jo["strRefTwo"];
    value->intRefTwo = jo["intRefTwo"];
  }

  void deserExternalClassType(jsonl::json & jo,ExternalClassType * value) {
        // TODO: REPLACE WITH SERIALIZATION CODE FOR CLASS ExternalClassType AS NECESSARY! VERIFY CLASS DEFINITION.
  }

  void deserExternalClassType4Coll(jsonl::json & jo,ExternalClassType4Coll * value) {
        // TODO: REPLACE WITH SERIALIZATION CODE FOR CLASS ExternalClassType4Coll AS NECESSARY! VERIFY CLASS DEFINITION.
  }

  void deserPrimitivesClass(jsonl::json & jo,PrimitivesClass * value) {
    value->byteOne = jo["byteOne"];
    value->strOne = jo["strOne"];
    value->longOne = jo["longOne"];
    value->dblOne = jo["dblOne"];
    value->intThree = jo["intThree"];
    value->boolOne = jo["boolOne"];
    value->intOne = jo["intOne"];
    value->charOne = jo["charOne"];
    value->intTwo = jo["intTwo"];
    value->shortOne = jo["shortOne"];
    value->flOne = jo["flOne"];
    deserArr(jo["flArr"], value->flArr);
    deserArr(jo["strArrOne"], value->strArrOne);
    deserArr(jo["dblArrOne"], value->dblArrOne);
    deserArr(jo["intArrOne"], value->intArrOne);
    deserArr(jo["boolArrOne"], value->boolArrOne);
    deserArr(jo["dblArrTwo"], value->dblArrTwo);
  }

  void deserAnnotatedClass(jsonl::json & jo,AnnotatedClass * value) {
    value->id = jo["id"];
    deserArr(jo["intArrExample"], value->intArrExample);
  }

  std::shared_ptr<IMjyRoot> deserObject(jsonl::json &  jo) {
    std::string cnid = jo["cnid"];

    if (cnid == "BaseClass") {
      std::shared_ptr<BaseClass> obj = std::make_shared<BaseClass>();
      deserBaseClass(jo, obj.get());
      return obj;
    }
    if (cnid == "DervClassOne") {
      std::shared_ptr<DervClassOne> obj = std::make_shared<DervClassOne>();
      deserDervClassOne(jo, obj.get());
      return obj;
    }
    if (cnid == "DervClassTwo") {
      std::shared_ptr<DervClassTwo> obj = std::make_shared<DervClassTwo>();
      deserDervClassTwo(jo, obj.get());
      return obj;
    }
    if (cnid == "RefClassOne") {
      std::shared_ptr<RefClassOne> obj = std::make_shared<RefClassOne>();
      deserRefClassOne(jo, obj.get());
      return obj;
    }
    if (cnid == "RefClassTwo") {
      std::shared_ptr<RefClassTwo> obj = std::make_shared<RefClassTwo>();
      deserRefClassTwo(jo, obj.get());
      return obj;
    }
    if (cnid == "ExternalClassType") {
      std::shared_ptr<ExternalClassType> obj = std::make_shared<ExternalClassType>();
      deserExternalClassType(jo, obj.get());
      return obj;
    }
    if (cnid == "ExternalClassType4Coll") {
      std::shared_ptr<ExternalClassType4Coll> obj = std::make_shared<ExternalClassType4Coll>();
      deserExternalClassType4Coll(jo, obj.get());
      return obj;
    }
    if (cnid == "PrimitivesClass") {
      std::shared_ptr<PrimitivesClass> obj = std::make_shared<PrimitivesClass>();
      deserPrimitivesClass(jo, obj.get());
      return obj;
    }
    if (cnid == "AnnotatedClass") {
      std::shared_ptr<AnnotatedClass> obj = std::make_shared<AnnotatedClass>();
      deserAnnotatedClass(jo, obj.get());
      return obj;
    }
    return nullptr;
  }


  template <typename T>
  void deserArr(jsonl::json jo, std::vector<T> & vec) {
    std::size_t size = jo.size();
    vec.clear();
    for (std::size_t i = 0; i < size; ++i) {
      vec.push_back(jo[i]);
    }
  }

  template <typename T>
  void deserArr(jsonl::json jo, std::vector<std::shared_ptr<T>> & vec) {
    std::size_t size = jo.size();
    vec.clear();
    for (std::size_t i = 0; i < size; ++i) {
      vec.push_back(std::dynamic_pointer_cast<T>(deserObject(jo[i])));
    }
  }

  template <typename T>
  void deserMap(jsonl::json jo, std::map<std::string, T> & map) {
    map.clear();
    auto it = jo.cbegin();
    while (it != jo.cend()) {
      map.emplace(it.key(), it.value());
      ++it;
    }
  }

  template <typename T>
  void deserMap(jsonl::json jo, std::map<std::string, std::shared_ptr<T>> & map) {
    map.clear();
    auto it = jo.cbegin();
    while (it != jo.cend()) {
      map.emplace(it.key(), std::dynamic_pointer_cast<T>(deserObject(jo[it.key()])));
      ++it;
    }
  }

  std::shared_ptr<IMjyRoot> deserialize(jsonl::json &  jo) {
    return deserObject(jo);
  }
  
  std::shared_ptr<IMjyRoot> deserialize(std::string jsonStr) {
    jsonl::json jo = jsonl::json::parse(jsonStr);
    return deserialize(jo);
  }


}; // class DemoProjectDeserializer


} // namespace demoproject
#endif // DemoProjectDeserializer_hpp
```